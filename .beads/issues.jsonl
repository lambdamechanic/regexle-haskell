{"id":"regex-1","title":"Regexle SBV reimplementation and benchmarking","description":"","status":"in_progress","priority":2,"issue_type":"epic","created_at":"2025-10-23T08:06:47.867161197+07:00","updated_at":"2025-10-26T07:44:37.854879636+07:00"}
{"id":"regex-10","title":"Add sydtest test suite","description":"Set up sydtest-based test suite for the Haskell project and cover Regexle.PuzzleCache functionality.","notes":"Added sydtest-based test suite (test-suite spec) with dependencies (sydtest, sydtest-aeson, sydtest-discover, temporary). Implemented PuzzleCacheSpec verifying cache path honors XDG_CACHE_HOME and fetchPuzzle reads cached JSON without network by pre-populating temp cache. cabal test now runs via sydtest-discover.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-23T08:51:41.790278076+07:00","updated_at":"2025-10-23T08:58:21.134200156+07:00","closed_at":"2025-10-23T08:58:21.134200156+07:00","dependencies":[{"issue_id":"regex-10","depends_on_id":"regex-7","type":"discovered-from","created_at":"2025-10-23T08:51:41.806412056+07:00","created_by":"mark"},{"issue_id":"regex-10","depends_on_id":"regex-1","type":"blocks","created_at":"2025-10-23T08:51:41.810688719+07:00","created_by":"mark"}]}
{"id":"regex-11","title":"Implement hot-solver path with SBV query mode","description":"Goal: reuse a single Z3 session via SBV’s query mode so we avoid re-emitting constraints every puzzle. See docs/hot-solver-sbv-notes.md for current findings (profiling, blocked experiment) and required work (freshVar-based grid rebuild, resetAssertions lifecycle, post-change profiling).","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-25T22:04:17.379914938+07:00","updated_at":"2025-10-26T07:00:06.216443771+07:00","closed_at":"2025-10-26T07:00:06.216443771+07:00"}
{"id":"regex-12","title":"Prototype direct Z3 backend","description":"Replace SBV with a thin Z3 binding so we can keep solver contexts hot, encode DFAs with native arrays, and avoid SMT-LIB emission. See docs/direct-z3-plan.md for rationale, task breakdown, and open questions.","status":"in_progress","priority":1,"issue_type":"task","created_at":"2025-10-25T22:04:36.171541504+07:00","updated_at":"2025-10-26T07:00:17.281786504+07:00"}
{"id":"regex-13","title":"Implement fastest Python method in Haskell solver","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-26T11:40:15.389835606+07:00","updated_at":"2025-10-26T11:52:01.94422431+07:00","closed_at":"2025-10-26T11:52:01.94422431+07:00"}
{"id":"regex-2","title":"Review nelhage regex resources","description":"Read nelhage-sandbox repo and blog post to extract existing SMT modeling and benchmarking approach for regex crosswords.","notes":"Reviewed nelhage-sandbox/regexle sources. Key takeaways: Python solver keeps regex cache, converts via greenery to minimized DFA, then flattens transitions + dead-state analysis for pruning (see third_party/nelhage-sandbox/regexle/src/regexle/main.py:1-520). Multiple matcher strategies exist: FuncMatcher encodes DFA as explicit z3.If ladder, z3.Function, or arrays; EnumMapper vs IntMapper toggles alphabet/state representation. Z3RE fallback uses native z3 regex encoding for comparison. Blog post (Oct 21 2025) documents major speedups from DFA encoding, pruning dead vocab, replacing UFs with explicit transition table, and benchmarking harness scanning regexle puzzles for runtime stats.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-23T08:06:56.37711539+07:00","updated_at":"2025-10-23T08:25:48.594566985+07:00","closed_at":"2025-10-23T08:25:48.594566985+07:00","dependencies":[{"issue_id":"regex-2","depends_on_id":"regex-1","type":"discovered-from","created_at":"2025-10-23T08:06:56.383279837+07:00","created_by":"mark"}]}
{"id":"regex-3","title":"Add nelhage-sandbox submodule","description":"Add https://github.com/nelhage/nelhage-sandbox as a git submodule in the repo to reuse benchmark assets.","notes":"Added git submodule at third_party/nelhage-sandbox for benchmark assets.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-23T08:07:05.748338213+07:00","updated_at":"2025-10-23T08:19:54.26127242+07:00","closed_at":"2025-10-23T08:19:54.26127242+07:00","dependencies":[{"issue_id":"regex-3","depends_on_id":"regex-1","type":"discovered-from","created_at":"2025-10-23T08:07:05.769030794+07:00","created_by":"mark"}]}
{"id":"regex-4","title":"Select Haskell FSM library","description":"Survey Haskell libraries that can replace greenery for DFA/NFA manipulation, evaluating suitability for regex crossword solving.","notes":"HaLeX: regex parser + NDFA/DFA pipeline with minimization and GraphViz export (Main.DFA, Main.RegExp modules), but last upload 1.2.6 in 2017 targeting GHC 6.8—expect patching before integrating. kleene: derivative-based regex compiler that returns minimized DFAs with explicit transition lookup, works for any Ord alphabet, exposes helpers like dfaBlackholes for dead states and toDot for visualization, and maps regex literals to AST via compile. Likely starting point for SBV integration: use kleene for DFA + pruning data, optionally borrow HaLeX minimizer if kleene gaps appear.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-23T08:07:13.781364004+07:00","updated_at":"2025-10-23T08:30:29.019615765+07:00","closed_at":"2025-10-23T08:30:29.019615765+07:00","dependencies":[{"issue_id":"regex-4","depends_on_id":"regex-1","type":"discovered-from","created_at":"2025-10-23T08:07:13.798441352+07:00","created_by":"mark"}]}
{"id":"regex-5","title":"Outline SBV-based solver","description":"Draft design for regexle solver using the Haskell SBV library, including data flow, constraint encoding, and integration points with benchmarks.","notes":"Drafted SBV solver outline in docs/sbv-solver-outline.md covering DFA generation with kleene, SBV grid/state encoding, dead-state pruning, and benchmark integration hooks.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-23T08:07:26.805619928+07:00","updated_at":"2025-10-23T09:10:51.663015476+07:00","closed_at":"2025-10-23T09:10:51.663015476+07:00","dependencies":[{"issue_id":"regex-5","depends_on_id":"regex-1","type":"discovered-from","created_at":"2025-10-23T08:07:26.826858858+07:00","created_by":"mark"}]}
{"id":"regex-6","title":"Plan cross-language benchmarks","description":"Define benchmarking strategy comparing Python regexle, Haskell SBV implementation, and alternative Haskell approaches, leveraging nelhage-sandbox scripts.","status":"in_progress","priority":2,"issue_type":"task","created_at":"2025-10-23T08:07:36.985664506+07:00","updated_at":"2025-10-23T11:58:36.987021638+07:00","dependencies":[{"issue_id":"regex-6","depends_on_id":"regex-1","type":"discovered-from","created_at":"2025-10-23T08:07:37.00215178+07:00","created_by":"mark"}]}
{"id":"regex-7","title":"Port nelhage puzzle fetch + cache","description":"Adapt Nelson's puzzle retrieval and local caching logic (regexle API + ~/.cache layout) for reuse in the Haskell benchmarking workflow.","notes":"Added cabal project scaffolding with library module Regexle.PuzzleCache exposing cacheRoot/puzzleCachePath/fetchPuzzle. Implementation mirrors Python flow: uses XDG cache (~/.cache/regexle), decodes cached JSON when present, otherwise fetches https://generator.regexle.com/api via http-client, validates HTTP 200, stores body, and parses puzzle schema. Executable now fetches day/side args and prints JSON.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-23T08:27:35.326523302+07:00","updated_at":"2025-10-23T08:49:46.852524987+07:00","closed_at":"2025-10-23T08:49:46.852524987+07:00","dependencies":[{"issue_id":"regex-7","depends_on_id":"regex-2","type":"discovered-from","created_at":"2025-10-23T08:27:35.341037972+07:00","created_by":"mark"},{"issue_id":"regex-7","depends_on_id":"regex-1","type":"blocks","created_at":"2025-10-23T08:27:35.345053428+07:00","created_by":"mark"}]}
{"id":"regex-8","title":"Implement DFA pruning constraints","description":"Ensure SBV solver enforces dead-state and dead-vocab pruning analogous to Nelson's numpy analysis for faster solving.","notes":"Implemented SBV-based solver using kleene DFA transitions with dead-state pruning (src/Regexle/Solver.hs). Added regex parser (Regexle.RegexParser) translating puzzle regex to Kleene ERE. CLI matrix/profile now run the solver: matrix records build/solve times, solution grid, or error if Z3 missing; profile aggregates solved count and averages. Tested with Z3 4.8.12 (Ubuntu package) producing solutions for days 400-402.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-23T08:28:00.307179721+07:00","updated_at":"2025-10-23T11:40:29.272162561+07:00","closed_at":"2025-10-23T10:27:03.976460286+07:00","dependencies":[{"issue_id":"regex-8","depends_on_id":"regex-2","type":"discovered-from","created_at":"2025-10-23T08:28:00.324533843+07:00","created_by":"mark"},{"issue_id":"regex-8","depends_on_id":"regex-5","type":"blocks","created_at":"2025-10-23T08:28:00.331059947+07:00","created_by":"mark"}]}
{"id":"regex-9","title":"Port benchmark matrix to Haskell","description":"Translate Nelson's profile/matrix benchmarking harness into Haskell to run comparisons across solver strategies.","notes":"Matrix/profile commands now wired to SBV solver. With Z3 installed (4.8.12), matrix side=3 days 400-402 solved puzzles in ~1.0-1.9s build, 0.07-0.13s solve; profile summarized 3/3 solved with avg build 1.53s, solve 0.106s.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-23T08:28:21.528788622+07:00","updated_at":"2025-10-23T11:40:42.887678214+07:00","closed_at":"2025-10-23T10:37:53.824360689+07:00","dependencies":[{"issue_id":"regex-9","depends_on_id":"regex-2","type":"discovered-from","created_at":"2025-10-23T08:28:21.542659495+07:00","created_by":"mark"},{"issue_id":"regex-9","depends_on_id":"regex-6","type":"blocks","created_at":"2025-10-23T08:28:21.549078258+07:00","created_by":"mark"}]}
